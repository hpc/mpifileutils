PROJECT(MFU)

CMAKE_MINIMUM_REQUIRED(VERSION 3.1)

IF(POLICY CMP0042)
  CMAKE_POLICY(SET CMP0042 NEW)
ENDIF(POLICY CMP0042)
SET(CMAKE_MACOSX_RPATH ON)
SET(CMAKE_POSITION_INDEPENDENT_CODE ON)

LIST(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")

# Configuration Options

OPTION(ENABLE_XATTRS "Enable code for extended attributes" ON)
IF(ENABLE_XATTRS)
  ADD_DEFINITIONS(-DDCOPY_USE_XATTRS)
ENDIF(ENABLE_XATTRS)

OPTION(ENABLE_LUSTRE "Enable optimization and features for Lustre" OFF)
IF(ENABLE_LUSTRE)
  ADD_DEFINITIONS(-DLUSTRE_SUPPORT)

  FIND_LIBRARY(LUSTREAPI lustreapi)
  IF(LUSTREAPI)
#  INCLUDE_DIRECTORIES(${LUSTREAPI_INCLUDE_DIRS})
    LIST(APPEND MFU_EXTERNAL_LIBS ${LUSTREAPI})
  ENDIF(LUSTREAPI)

  INCLUDE(CheckLibraryExists)

  CHECK_LIBRARY_EXISTS(lustreapi llapi_layout_alloc ${LUSTREAPI} HAVE_LLAPI_LAYOUT)
  IF(HAVE_LLAPI_LAYOUT)
    ADD_DEFINITIONS(-DHAVE_LLAPI_LAYOUT)
  ENDIF(HAVE_LLAPI_LAYOUT)

  CHECK_LIBRARY_EXISTS(lustreapi llapi_file_create ${LUSTREAPI} HAVE_LLAPI_FILE_CREATE)
  IF(HAVE_LLAPI_FILE_CREATE)
    ADD_DEFINITIONS(-DHAVE_LLAPI_FILE_CREATE)
  ENDIF(HAVE_LLAPI_FILE_CREATE)

  CHECK_LIBRARY_EXISTS(lustreapi llapi_file_get_stripe ${LUSTREAPI} HAVE_LLAPI_FILE_GET_STRIPE)
  IF(HAVE_LLAPI_FILE_GET_STRIPE)
    ADD_DEFINITIONS(-DHAVE_LLAPI_FILE_GET_STRIPE)
  ENDIF(HAVE_LLAPI_FILE_GET_STRIPE)

  # todo investigate usage of other lustre #defs
  # - LUSTRE_STAT
ENDIF(ENABLE_LUSTRE)

OPTION(ENABLE_GPFS "Enable GFPS/Spectrum Scale support")
IF(ENABLE_GPFS)
  FIND_PACKAGE(GPFS REQUIRED)
  INCLUDE_DIRECTORIES(${GPFS_INCLUDE_DIRS})
  LIST(APPEND MFU_EXTERNAL_LIBS ${GPFS_LIBRARIES})
  ADD_DEFINITIONS(-DGPFS_SUPPORT)
ENDIF(ENABLE_GPFS)

OPTION(ENABLE_EXPERIMENTAL "Build experimental tools" OFF)

## HEADERS
INCLUDE(CheckIncludeFile)
CHECK_INCLUDE_FILE(byteswap.h HAVE_BYTESWAP_H)
if(HAVE_BYTESWAP_H)
  ADD_DEFINITIONS(-DHAVE_BYTESWAP_H)
ELSE(HAVE_BYTESWAP_H)
  MESSAGE(SEND_ERROR "byteswap.h is required")
ENDIF(HAVE_BYTESWAP_H)

# Dependencies

## MPI
INCLUDE(SetupMPI)
INCLUDE_DIRECTORIES(${MPI_C_INCLUDE_PATH})
LIST(APPEND MFU_EXTERNAL_LIBS ${MPI_C_LIBRARIES})

## DTCMP
FIND_PACKAGE(DTCMP REQUIRED)
INCLUDE_DIRECTORIES(${DTCMP_INCLUDE_DIRS})
LIST(APPEND MFU_EXTERNAL_LIBS ${DTCMP_LIBRARIES})

## LIBARCHIVE
OPTION(ENABLE_LIBARCHIVE "Enable usage of libarchive and corresponding tools" ON)
# TODO how would we pass a version from spack?
# libarchive 3.1.2 is available on some systems,
# but pick a newer libarchive to avoid bug with files starting with "._",
# which is misinterpretted as a MacOS extension on Linuxlibarchive 3.1.2
IF(ENABLE_LIBARCHIVE)
  FIND_PACKAGE(LibArchive 3.5.1 REQUIRED)
  INCLUDE_DIRECTORIES(${LibArchive_INCLUDE_DIRS})
  LIST(APPEND MFU_EXTERNAL_LIBS ${LibArchive_LIBRARIES})
  ADD_DEFINITIONS(-DLIBARCHIVE_SUPPORT)
ENDIF(ENABLE_LIBARCHIVE)

OPTION(ENABLE_DAOS "Enable DAOS support")
IF(ENABLE_DAOS)
  SET(CMAKE_EXE_LINKER_FLAGS -luuid)
  FIND_PACKAGE(CART REQUIRED)
  INCLUDE_DIRECTORIES(${CART_INCLUDE_DIRS})
  message(${CART_INCLUDE_DIRS})
  LIST(APPEND MFU_EXTERNAL_LIBS ${CART_LIBRARIES})
  LIST(APPEND MFU_EXTERNAL_LIBS ${GURT_LIBRARIES})
  FIND_PACKAGE(DAOS REQUIRED)
  INCLUDE_DIRECTORIES(${DAOS_INCLUDE_DIRS})
  LIST(APPEND MFU_EXTERNAL_LIBS ${DAOS_LIBRARIES})
  LIST(APPEND MFU_EXTERNAL_LIBS ${DUNS_LIBRARIES})
  LIST(APPEND MFU_EXTERNAL_LIBS ${DFS_LIBRARIES})
  LIST(APPEND MFU_EXTERNAL_LIBS ${DAOS_COMMON_LIBRARIES})
  ADD_DEFINITIONS(-DDAOS_SUPPORT)
ENDIF(ENABLE_DAOS)

## LIBCIRCLE
FIND_PACKAGE(LibCircle REQUIRED)
INCLUDE_DIRECTORIES(${LibCircle_INCLUDE_DIRS})
LIST(APPEND MFU_EXTERNAL_LIBS ${LibCircle_LIBRARIES})

## BZip2
FIND_PACKAGE(BZip2 REQUIRED)
LIST(APPEND MFU_EXTERNAL_LIBS ${BZIP2_LIBRARIES})

## libcap for checks on linux capabilities
FIND_PACKAGE(LibCap)
IF(LibCap_FOUND)
  ADD_DEFINITIONS(-DHAVE_LIBCAP)
  INCLUDE_DIRECTORIES(${LibCap_INCLUDE_DIRS})
  LIST(APPEND MFU_EXTERNAL_LIBS ${LibCap_LIBRARIES})
ENDIF(LibCap_FOUND)

## OPENSSL for ddup
FIND_PACKAGE(OpenSSL)

# Setup Installation

INCLUDE(GNUInstallDirs)
SET(X_BINDIR ${CMAKE_INSTALL_FULL_BINDIR} CACHE INTERNAL "bin")
SET(X_DATADIR ${CMAKE_INSTALL_FULL_DATADIR} CACHE INTERNAL "share")
SET(X_INCLUDEDIR ${CMAKE_INSTALL_FULL_INCLUDEDIR} CACHE INTERNAL "include")
SET(X_LIBDIR ${CMAKE_INSTALL_FULL_LIBDIR} CACHE INTERNAL "lib")

############
# This sets an rpath to buildtime libraries in build directory
# and rewrites the rpath to the install location during install
# these lines must come before add_library and add_executable macros
############

# https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/RPATH-handling
# use, i.e. don't skip the full RPATH for the build tree
SET(CMAKE_SKIP_BUILD_RPATH  FALSE)

# when building, don't use the install RPATH already
# (but later on when installing)
SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)

SET(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")

# add the automatically determined parts of the RPATH
# which point to directories outside the build tree to the install RPATH
SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)

# the RPATH to be used when installing, but only if it's not a system directory
LIST(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}" isSystemDir)
IF("${isSystemDir}" STREQUAL "-1")
   SET(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
ENDIF("${isSystemDir}" STREQUAL "-1")

############
# End rpath stuff
############

# Subdirectories
INCLUDE(MFU_ADD_TOOL)
INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/src/common)

ADD_SUBDIRECTORY(src)
ADD_SUBDIRECTORY(test)
ADD_SUBDIRECTORY(man)
